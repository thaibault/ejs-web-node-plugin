<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.compiled.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.compiled.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
var templatewebnodeplugin =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module &amp;&amp; module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__dirname) {// #!/usr/bin/env node
// -*- coding: utf-8 -*-
/** @module templateWebNodePlugin *//* !
    region header
    [Project page](http://torben.website/templateWebNodePlugin)

    Copyright Torben Sickert (info["~at~"]torben.website) 16.12.2012

    License
    -------

    This library written by Torben Sickert stand under a creative commons
    naming 3.0 unported license.
    See http://creativecommons.org/licenses/by/3.0/deed.de
    endregion
*/// region imports
exports.__esModule=true;exports.Template=undefined;var _promise=__webpack_require__(2);var _promise2=_interopRequireDefault(_promise);var _asyncToGenerator2=__webpack_require__(3);var _asyncToGenerator3=_interopRequireDefault(_asyncToGenerator2);var _clientnode=__webpack_require__(4);var _clientnode2=_interopRequireDefault(_clientnode);var _ejs=__webpack_require__(5);var _ejs2=_interopRequireDefault(_ejs);var _fs=__webpack_require__(6);var _fs2=_interopRequireDefault(_fs);var _path=__webpack_require__(7);var _path2=_interopRequireDefault(_path);var _pluginAPI=__webpack_require__(8);var _pluginAPI2=_interopRequireDefault(_pluginAPI);function _interopRequireDefault(obj){return obj&amp;&amp;obj.__esModule?obj:{default:obj}}// NOTE: Only needed for debugging this file.
try{__webpack_require__(9)}catch(error){}// endregion
/**
 * Renders all templates again configuration object and re-renders them after
 * configurations changes.
 * @property static:entryFiles - Mapping from auto determined file paths to
 * there compiled template function.
 * @property static:files - Mapping from determined file paths to there
 * compiled template function.
 */class Template{// region api
/**
     * Triggered hook when at least one plugin has a new configuration file and
     * configuration object has been changed.
     * @param configuration - Updated configuration object.
     * @param pluginsWithChangedConfiguration - List of plugins which have a
     * changed plugin configuration.
     * @param oldConfiguration - Old configuration object.
     * @param plugins - List of all loaded plugins.
     * @returns New configuration object to use.
     */static postConfigurationLoaded(configuration,pluginsWithChangedConfiguration,oldConfiguration,plugins){return(0,_asyncToGenerator3.default)(function*(){if(configuration.template.renderAfterConfigurationUpdates)Template.render(null,configuration,plugins);return configuration})()}/**
     * Appends an template renderer to the web node services.
     * @param services - An object with stored service instances.
     * @returns Given and extended object of services.
     */static preLoadService(services){services.template={render:Template.render.bind(Template),renderFactory:Template.renderFactory.bind(Template)};return services}/**
     * Triggers when application will be closed soon and removes created files.
     * @param services - An object with stored service instances.
     * @param configuration - Updated configuration object.
     * @returns Given object of services.
     */static shouldExit(services,configuration){return(0,_asyncToGenerator3.default)(function*(){const templateOutputRemoveingPromises=[];for(const filePath in Template.files)if(Template.files.hasOwnProperty(filePath)&amp;&amp;!configuration.template.inPlaceReplacementPaths.includes(filePath))templateOutputRemoveingPromises.push(new _promise2.default((()=>{var _ref=(0,_asyncToGenerator3.default)(function*(resolve,reject){const newFilePath=filePath.substring(0,filePath.length-_path2.default.extname(filePath).length);let newFileExists=false;try{newFileExists=yield _clientnode2.default.isFile(newFilePath)}catch(error){reject(error)}if(newFileExists)_fs2.default.unlink(newFilePath,function(error){return error?reject(error):resolve(newFilePath)});else resolve(newFileExists)});return function(_x,_x2){return _ref.apply(this,arguments)}})()));yield _promise2.default.all(templateOutputRemoveingPromises);return services})()}// endregion
// region helper
/**
     * Retrieves all files to process.
     * @param configuration - Updated configuration object.
     * @param plugins - List of all loaded plugins.
     * @returns A promise holding all resolved files.
     */static getEntryFiles(configuration,plugins){return(0,_asyncToGenerator3.default)(function*(){if(Template.entryFiles&amp;&amp;!configuration.template.reloadEntryFiles)return Template.entryFiles;const pluginPaths=plugins.map(function(plugin){return plugin.path});Template.entryFiles={};for(const file of(yield _clientnode2.default.walkDirectoryRecursively(configuration.context.path,function(file){if(file.name.startsWith('.'))return false;/*
                    NOTE: We want to ignore all known plugin locations which
                    aren't loaded.
                */for(const type in configuration.plugin.directories)if(configuration.plugin.directories.hasOwnProperty(type)&amp;&amp;_path2.default.dirname(file.path)===_path2.default.resolve(configuration.plugin.directories[type].path)&amp;&amp;!pluginPaths.includes(file.path))return false;/*
                    NOTE: We ignore absolute defined locations and relative
                    defined in each loaded plugin location.
                */for(const locationToIgnore of configuration.template.locationsToIgnore)if(locationToIgnore.startsWith('/')){if(file.path.startsWith(_path2.default.join(configuration.context.path,locationToIgnore)))return false}else for(const pluginPath of pluginPaths)if(file.path.startsWith(_path2.default.resolve(pluginPath,locationToIgnore)))return false})).filter(function(file){return file.stat.isFile()&amp;&amp;configuration.template.extensions.filter(function(extension/*
                NOTE: We can't use "path.extname()" here since double
                extensions like ".html.js" should be supported.
            */){return file.name.endsWith(extension)}).length>0}))Template.entryFiles[file.path]=null;for(const filePath of configuration.template.inPlaceReplacementPaths)Template.entryFiles[filePath]=null;for(const filePath in Template.entryFiles)if(Template.entryFiles.hasOwnProperty(filePath))Template.files[filePath]=Template.entryFiles[filePath];return Template.entryFiles})()}/**
     * Triggers template rendering.
     * @param givenScope - Scope to use for rendering templates.
     * @param configuration - Configuration object.
     * @param plugins - List of all loaded plugins.
     * @returns A promise resolving to scope used for template rendering.
     */static render(givenScope,configuration,plugins){return(0,_asyncToGenerator3.default)(function*(){const scope=_clientnode2.default.extendObject(true,{basePath:configuration.context.path},configuration.template.scope.plain,givenScope||{});for(const type of['evaluation','execution'])for(const name in configuration.template.scope[type])if(configuration.template.scope[type].hasOwnProperty(name))// IgnoreTypeCheck
scope[name]=new Function('configuration','currentPath','fileSystem','parser','path','PluginAPI','plugins','require','scope','template','Tools','webNodePath',type==='evaluation'?'return '+configuration.template.scope[type][name]:configuration.template.scope[type][name])(_clientnode2.default.copyLimitedRecursively(configuration,-1,true),process.cwd(),_fs2.default,_ejs2.default,_path2.default,_pluginAPI2.default,plugins,eval('require'),scope,Template,_clientnode2.default,__dirname);const options=_clientnode2.default.copyLimitedRecursively(configuration.template.options);scope.include=Template.renderFactory(configuration,scope,options);Template.entryFiles=yield _pluginAPI2.default.callStack('preTemplateRender',plugins,configuration,(yield Template.getEntryFiles(configuration,plugins)),scope);const templateRenderingPromises=[];for(const filePath in Template.entryFiles)if(Template.entryFiles.hasOwnProperty(filePath))templateRenderingPromises.push(new _promise2.default((()=>{var _ref2=(0,_asyncToGenerator3.default)(function*(resolve,reject){const currentScope=_clientnode2.default.extendObject({},scope);const inPlace=configuration.template.inPlaceReplacementPaths.includes(filePath);const newFilePath=inPlace?filePath:filePath.substring(0,filePath.length-_path2.default.extname(filePath).length);if(inPlace&amp;&amp;configuration.template.cacheInPlaceReplacements&amp;&amp;Template.entryFiles[filePath]||!inPlace&amp;&amp;configuration.template.cache&amp;&amp;(yield _clientnode2.default.isFile(newFilePath))){console.info(`Template: Use cached file ("${newFilePath}") `+`for "${filePath}".`);resolve(newFilePath)}else{const currentOptions=_clientnode2.default.extendObject({},options,{filename:_path2.default.relative(currentScope.basePath,filePath)});if(!('options'in currentScope))currentScope.options=currentOptions;if(!('plugins'in currentScope))currentScope.plugins=plugins;const result=Template.renderFactory(configuration,currentScope,currentOptions)(filePath);if(result)try{_fs2.default.writeFile(newFilePath,result,{encoding:configuration.encoding,flag:'w',mode:438},function(error){return error?reject(error):resolve(newFilePath)})}catch(error){reject(error)}}});return function(_x3,_x4){return _ref2.apply(this,arguments)}})()));yield _promise2.default.all(templateRenderingPromises);return yield _pluginAPI2.default.callStack('postTemplateRender',plugins,configuration,scope,Template.entryFiles)})()}/**
     * Generates a render function with given base scope to resolve includes.
     * @param configuration - Configuration object.
     * @param scope - Base scope to extend from.
     * @param options - Render options to use.
     * @returns Render function.
     */static renderFactory(configuration,scope={},options={}){if(!scope.basePath)scope.basePath=configuration.context.path;if(!options.preCompiledTemplateFileExtensions)options.preCompiledTemplateFileExtensions=['.js'];return(filePath,nestedLocals={})=>{let nestedOptions=_clientnode2.default.copyLimitedRecursively(options);delete nestedOptions.client;nestedOptions=_clientnode2.default.extendObject(true,{encoding:'utf-8'},nestedOptions,nestedLocals.options||{});const nestedScope=_clientnode2.default.extendObject({},scope);filePath=_path2.default.resolve(scope.basePath,filePath);nestedOptions.filename=_path2.default.relative(scope.basePath,filePath);nestedScope.basePath=_path2.default.dirname(filePath);nestedScope.include=Template.renderFactory(configuration,nestedScope,nestedOptions);nestedScope.options=nestedOptions;nestedScope.scope=nestedScope;_clientnode2.default.extendObject(nestedScope,nestedLocals);let currentFilePath=null;for(const extension of[''].concat(configuration.template.extensions))if(_clientnode2.default.isFileSync(filePath+extension)){currentFilePath=filePath+extension;break}if(currentFilePath){if(configuration.template.reloadSourceContent&amp;&amp;!configuration.template.inPlaceReplacementPaths.includes(filePath)||!(Template.files.hasOwnProperty(currentFilePath)&amp;&amp;Template.files[currentFilePath]))if(nestedOptions.preCompiledTemplateFileExtensions.includes(_path2.default.extname(currentFilePath)))try{Template.files[currentFilePath]=eval('require')(currentFilePath)}catch(error){throw new Error('Error occurred during loading script module'+`: "${currentFilePath}": `+_clientnode2.default.representObject(error))}else{let template;try{// IgnoreTypeCheck
template=_fs2.default.readFileSync(currentFilePath,{encoding:nestedOptions.encoding})}catch(error){throw new Error('Error occurred during loading template '+`file "${currentFilePath}" from file system:`+` ${_clientnode2.default.representObject(error)}`)}try{Template.files[currentFilePath]=_ejs2.default.compile(template,nestedOptions)}catch(error){throw new Error('Error occurred during compiling template '+`file "${currentFilePath}" with base path "`+`${nestedScope.basePath}": `+_clientnode2.default.representObject(error))}}try{// IgnoreTypeCheck
return Template.files[currentFilePath](nestedScope)}catch(error){let scopeDescription='';try{scopeDescription='scope '+_clientnode2.default.representObject(nestedScope)+' against'}catch(error){}throw new Error('Error occurred during running template '+`${scopeDescription}file "${currentFilePath}": `+_clientnode2.default.representObject(error))}}throw new Error(`Given template file "${nestedOptions.filename}" couldn't be`+' resolved (with known extensions: "'+`${configuration.template.extensions.join('", "')}") in "`+`${scope.basePath}".`)}}// endregion
}exports.Template=Template;Template.files={};exports.default=Template;// region vim modline
// vim: set tabstop=4 shiftwidth=4 expandtab:
// vim: foldmethod=marker foldmarker=region,endregion:
// endregion
/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_7__;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

if(typeof __WEBPACK_EXTERNAL_MODULE_9__ === 'undefined') {var e = new Error("Cannot find module \"source-map-support/register\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ })
/******/ ]);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-templateWebNodePlugin.html">templateWebNodePlugin</a></li></ul><h3>Classes</h3><ul><li><a href="module-templateWebNodePlugin-Template.html">Template</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Nov 22 2017 19:33:58 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
